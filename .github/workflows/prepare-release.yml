name: Prepare Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major
      base_branch:
        description: 'Base branch to create release from'
        required: true
        default: 'main'
        type: string

jobs:
  prepare-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.inputs.base_branch }}
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Get latest release tag
      id: latest_tag
      run: |
        # Get the latest release tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Latest release tag: $LATEST_TAG"
    
    - name: Calculate new version
      id: new_version
      run: |
        LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"
        # Remove 'v' prefix if present
        VERSION=${LATEST_TAG#v}
        
        # Split version into components
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]:-0}
        MINOR=${VERSION_PARTS[1]:-0}
        PATCH=${VERSION_PARTS[2]:-0}
        
        case "${{ github.event.inputs.release_type }}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac
        
        NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "version_number=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT
        echo "New version: $NEW_VERSION"
    
    - name: Create release branch
      id: release_branch
      run: |
        RELEASE_BRANCH="release/${{ steps.new_version.outputs.new_version }}"
        echo "branch_name=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
        
        git checkout -b "$RELEASE_BRANCH"
        echo "Created release branch: $RELEASE_BRANCH"
    
    - name: Generate changelog
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"
        DATE=$(date '+%Y-%m-%d')
        
        echo "Generating changelog from $LATEST_TAG to HEAD..."
        
        # Create or update CHANGELOG.md
        cat > CHANGELOG_NEW.md << EOF
        # Changelog
        
        All notable changes to this project will be documented in this file.
        
        ## [${{ steps.new_version.outputs.version_number }}] - $DATE
        
        EOF
        
        # Get commits since last release
        if [ "$LATEST_TAG" != "v0.0.0" ]; then
          COMMITS=$(git log --pretty=format:"- %s" --no-merges ${LATEST_TAG}..HEAD)
        else
          COMMITS=$(git log --pretty=format:"- %s" --no-merges)
        fi
        
        if [ -n "$COMMITS" ]; then
          echo "### Changes" >> CHANGELOG_NEW.md
          echo "$COMMITS" >> CHANGELOG_NEW.md
        else
          echo "### Changes" >> CHANGELOG_NEW.md
          echo "- No notable changes" >> CHANGELOG_NEW.md
        fi
        
        echo "" >> CHANGELOG_NEW.md
        
        # If CHANGELOG.md exists, append old content
        if [ -f CHANGELOG.md ]; then
          echo "" >> CHANGELOG_NEW.md
          tail -n +3 CHANGELOG.md >> CHANGELOG_NEW.md 2>/dev/null || true
        fi
        
        mv CHANGELOG_NEW.md CHANGELOG.md
        echo "Updated CHANGELOG.md"
    
    - name: Generate release notes
      run: |
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        VERSION_NUMBER="${{ steps.new_version.outputs.version_number }}"
        LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"
        DATE=$(date '+%B %d, %Y')
        
        cat > RELEASE_NOTES.txt << EOF
        # ztictl $NEW_VERSION Release Notes
        
        **Release Date:** $DATE
        
        ## What's New in $VERSION_NUMBER
        
        EOF
        
        # Get commits since last release and categorize them
        if [ "$LATEST_TAG" != "v0.0.0" ]; then
          COMMITS=$(git log --pretty=format:"%s" --no-merges ${LATEST_TAG}..HEAD)
        else
          COMMITS=$(git log --pretty=format:"%s" --no-merges)
        fi
        
        # Categorize commits
        FEATURES=""
        FIXES=""
        IMPROVEMENTS=""
        OTHER=""
        
        while IFS= read -r commit; do
          case "$commit" in
            feat*|feature*|add*)
              FEATURES="$FEATURES- $commit"$'\n'
              ;;
            fix*|bug*)
              FIXES="$FIXES- $commit"$'\n'
              ;;
            improve*|enhance*|update*|refactor*)
              IMPROVEMENTS="$IMPROVEMENTS- $commit"$'\n'
              ;;
            *)
              OTHER="$OTHER- $commit"$'\n'
              ;;
          esac
        done <<< "$COMMITS"
        
        # Add sections if they have content
        if [ -n "$FEATURES" ]; then
          echo "### 🚀 New Features" >> RELEASE_NOTES.txt
          echo "$FEATURES" >> RELEASE_NOTES.txt
        fi
        
        if [ -n "$IMPROVEMENTS" ]; then
          echo "### ✨ Improvements" >> RELEASE_NOTES.txt
          echo "$IMPROVEMENTS" >> RELEASE_NOTES.txt
        fi
        
        if [ -n "$FIXES" ]; then
          echo "### 🐛 Bug Fixes" >> RELEASE_NOTES.txt
          echo "$FIXES" >> RELEASE_NOTES.txt
        fi
        
        if [ -n "$OTHER" ]; then
          echo "### 📝 Other Changes" >> RELEASE_NOTES.txt
          echo "$OTHER" >> RELEASE_NOTES.txt
        fi
        
        # Add installation instructions
        cat >> RELEASE_NOTES.txt << EOF
        
        ## 📦 Installation
        
        ### Quick Install
        \`\`\`bash
        # Linux (AMD64)
        curl -L https://github.com/zsoftly/ztiaws/releases/latest/download/ztictl-linux-amd64 -o ztictl
        chmod +x ztictl && sudo mv ztictl /usr/local/bin/
        
        # macOS (Intel)
        curl -L https://github.com/zsoftly/ztiaws/releases/latest/download/ztictl-darwin-amd64 -o ztictl
        chmod +x ztictl && sudo mv ztictl /usr/local/bin/
        
        # macOS (Apple Silicon)
        curl -L https://github.com/zsoftly/ztiaws/releases/latest/download/ztictl-darwin-arm64 -o ztictl
        chmod +x ztictl && sudo mv ztictl /usr/local/bin/
        
        # Windows (PowerShell)
        Invoke-WebRequest -Uri "https://github.com/zsoftly/ztiaws/releases/latest/download/ztictl-windows-amd64.exe" -OutFile "ztictl.exe"
        \`\`\`
        
        ### Manual Download
        Download the appropriate binary for your platform from the [releases page](https://github.com/zsoftly/ztiaws/releases/tag/$NEW_VERSION).
        
        ## 🚀 Quick Start
        
        \`\`\`bash
        # Verify installation
        ztictl --version
        
        # Configure and login
        ztictl auth login
        
        # List instances
        ztictl ssm list --region us-east-1
        
        # Connect to an instance
        ztictl ssm connect --region us-east-1 --instance-id i-1234567890abcdef0
        \`\`\`
        
        **Full documentation**: [README.md](README.md)
        **Issues?** Report them on [GitHub Issues](https://github.com/zsoftly/ztiaws/issues)
        EOF
        
        echo "Generated RELEASE_NOTES.txt"
    
    - name: Commit changes
      run: |
        git add CHANGELOG.md RELEASE_NOTES.txt
        git commit -m "chore: prepare release ${{ steps.new_version.outputs.new_version }}

        - Updated CHANGELOG.md with latest changes
        - Generated RELEASE_NOTES.txt for release
        - Automated preparation for ${{ steps.new_version.outputs.new_version }}"
    
    - name: Push release branch
      run: |
        git push origin "${{ steps.release_branch.outputs.branch_name }}"
    
    - name: Create Pull Request
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        RELEASE_BRANCH="${{ steps.release_branch.outputs.branch_name }}"
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"
        
        gh pr create \
          --title "Release $NEW_VERSION" \
          --body "🚀 **Automated Release Preparation for $NEW_VERSION**

        This PR contains the automated preparation for release $NEW_VERSION:

        - ✅ Updated CHANGELOG.md with latest changes since ${{ steps.latest_tag.outputs.latest_tag }}
        - ✅ Generated RELEASE_NOTES.txt with categorized changes
        - ✅ Ready for review and release tag creation

        ## Next Steps
        1. **Review** the generated changelog and release notes
        2. **Edit** if needed (directly in this branch)
        3. **Approve** this PR when ready
        4. **Create release tag** from this branch: \`git tag $NEW_VERSION && git push origin $NEW_VERSION\`
        5. **Merge** this PR back to main after release is published

        ## Changes in this release
        $(cat CHANGELOG.md | head -20)

        **Release type**: ${{ github.event.inputs.release_type }}
        **Base branch**: ${{ github.event.inputs.base_branch }}" \
          --base main \
          --head "$RELEASE_BRANCH"
        
        echo "Created pull request for release preparation"
    
    - name: Summary
      run: |
        echo "## 🎉 Release Preparation Complete!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**New Version**: ${{ steps.new_version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Release Branch**: ${{ steps.release_branch.outputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Previous Version**: ${{ steps.latest_tag.outputs.latest_tag }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### What was automated:" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Created release branch" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Generated CHANGELOG.md" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Generated RELEASE_NOTES.txt" >> $GITHUB_STEP_SUMMARY
        echo "- ✅ Created pull request for review" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next steps:" >> $GITHUB_STEP_SUMMARY  
        echo "1. Review the generated files in the PR" >> $GITHUB_STEP_SUMMARY
        echo "2. Make any manual edits if needed" >> $GITHUB_STEP_SUMMARY
        echo "3. Create and push release tag to trigger release build" >> $GITHUB_STEP_SUMMARY
        echo "4. Merge PR back to main after release" >> $GITHUB_STEP_SUMMARY
