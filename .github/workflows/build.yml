name: CI/CD Pipeline

# Git Flow Pattern:
# 1. Create release branch from main (e.g., release/v2.0.0)
# 2. Make release preparations (version updates, changelog, etc.)
# 3. Push tag to trigger this workflow (e.g., v2.0.0)
# 4. Workflow builds, tests, and creates GitHub release
# 5. MANUAL: Merge release branch back to main when ready
# 6. Main branch stays up-to-date with all release changes

on:
  push:
    branches: [ main, 'feature/*', 'feat/*', 'issue/*', 'release/*' ]
    tags:
      - 'v*'
    paths:
      - 'ztictl/**'
      - 'authaws'
      - 'ssm'
      - 'src/**'
      - 'tests/**'
      - 'tools/**'
      - 'install.sh'
      - 'uninstall.sh'
      - '.github/workflows/build.yml'
      - 'go.mod'
      - 'go.sum'
      - 'Makefile'
      - 'CHANGELOG.md'
  pull_request:
    branches: [ main, 'release/*' ]
    paths:
      - 'ztictl/**'
      - 'authaws'
      - 'ssm'
      - 'src/**'
      - 'tests/**'
      - 'tools/**'
      - 'install.sh'
      - 'uninstall.sh'
      - '.github/workflows/build.yml'
      - 'go.mod'
      - 'go.sum'
      - 'Makefile'
      - 'CHANGELOG.md'
  workflow_dispatch:

jobs:
  test-shell:
    name: Test Shell Scripts
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/'))
    
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        
    steps:
    - uses: actions/checkout@v4
    
    - name: Install shellcheck
      run: |
        if [ "$RUNNER_OS" == "Linux" ]; then
          sudo apt-get update && sudo apt-get install -y shellcheck
        else
          brew install shellcheck
        fi
      shell: bash

    - name: Run shellcheck on shell scripts
      run: |
        echo "Checking shell scripts..."
        shellcheck -x authaws ssm src/*.sh tools/*.sh install.sh uninstall.sh
        echo "Shell scripts passed validation"

    - name: Test shell script syntax
      run: |
        echo "Testing shell script syntax..."
        for script in authaws ssm src/*.sh tools/*.sh; do
          if [ -f "$script" ]; then
            bash -n "$script" || exit 1
          fi
        done
        echo "Shell script syntax is valid"

    - name: Notify on shell test failure
      if: failure() && matrix.os == 'ubuntu-latest' && github.event_name == 'pull_request'
      env:
        GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
      run: |
        if [[ -n "$GOOGLE_CHAT_WEBHOOK" ]]; then
          ./scripts/send-pr-notification.sh \
            --pr-title '${{ github.event.pull_request.title }}' \
            --pr-number '${{ github.event.pull_request.number }}' \
            --pr-url '${{ github.event.pull_request.html_url }}' \
            --author '${{ github.event.pull_request.user.login }}' \
            --repository '${{ github.repository }}' \
            --status "failure" \
            --message "âŒ Shell script tests failed - PR needs attention" || true
        fi
      continue-on-error: true

  test-go:
    name: Test Go Code
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/'))
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.25'
        
    - name: Get dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Run tests
      working-directory: ./ztictl
      env:
        # Use mock AWS credentials for testing - matches internal/testutil/aws.go
        AWS_EC2_METADATA_DISABLED: "true"
        AWS_ACCESS_KEY_ID: "AKIAIOSFODNN7EXAMPLE"
        AWS_SECRET_ACCESS_KEY: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
        AWS_SESSION_TOKEN: "test-session-token"
        AWS_REGION: "ca-central-1"
      run: go test ./...
        
    - name: Run go vet
      working-directory: ./ztictl
      run: go vet ./...
      
    - name: Check formatting
      working-directory: ./ztictl
      shell: bash
      run: |
        # Ensure consistent line endings across platforms
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          # Configure git to handle line endings properly for this check
          git config core.autocrlf false
          # Re-checkout files with correct line endings
          git checkout HEAD -- .
        fi
        
        # Check if any files need formatting
        UNFORMATTED=$(gofmt -s -l .)
        if [ -n "$UNFORMATTED" ]; then
          echo "The following files are not formatted correctly:"
          echo "$UNFORMATTED"
          echo ""
          echo "Please run 'gofmt -s -w .' to fix formatting issues."
          exit 1
        fi
        echo "All Go files are properly formatted."
    
    - name: Test build
      working-directory: ./ztictl
      run: go build -o ztictl${{ matrix.os == 'windows-latest' && '.exe' || '' }} ./cmd/ztictl
    
    - name: Test CLI commands (no auth required)
      working-directory: ./ztictl
      shell: bash
      run: |
        # Set executable name based on OS
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          ZTICTL_EXE="./ztictl.exe"
        else
          ZTICTL_EXE="./ztictl"
        fi
        
        # Test help commands
        $ZTICTL_EXE --help
        $ZTICTL_EXE config --help
        $ZTICTL_EXE auth --help
        $ZTICTL_EXE ssm --help
        
        # Test version
        $ZTICTL_EXE --version
        
        # Test config validation (should fail gracefully without config)
        $ZTICTL_EXE config validate || echo "Expected to fail without config"
        
        # Test config show (should show defaults)
        $ZTICTL_EXE config show || echo "Expected to work with defaults"
        
        # Test system check (should work without AWS)
        $ZTICTL_EXE config check || echo "Expected to show missing dependencies"

    - name: Notify on Go test failure
      if: failure() && matrix.os == 'ubuntu-latest' && github.event_name == 'pull_request'
      env:
        GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
      run: |
        if [[ -n "$GOOGLE_CHAT_WEBHOOK" ]]; then
          ./scripts/send-pr-notification.sh \
            --pr-title '${{ github.event.pull_request.title }}' \
            --pr-number '${{ github.event.pull_request.number }}' \
            --pr-url '${{ github.event.pull_request.html_url }}' \
            --author '${{ github.event.pull_request.user.login }}' \
            --repository '${{ github.repository }}' \
            --status "failure" \
            --message "âŒ Go tests failed - PR needs attention" || true
        fi
      continue-on-error: true

  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    needs: [test-shell, test-go]
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    env:
      GOPROXY: proxy.golang.org,direct
      GOSUMDB: sum.golang.org
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.25'
        
    - name: Download dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Install security tools
      run: |
        # Install govulncheck for official Go vulnerability checking
        go install golang.org/x/vuln/cmd/govulncheck@latest
        
        # Install golangci-lint v2.4.0 for comprehensive linting and security checks
        # Using specific version to match local development environment
        curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v2.4.0
        
        # Verify installations
        govulncheck -version || echo "govulncheck installation failed"
        $(go env GOPATH)/bin/golangci-lint version || echo "golangci-lint installation failed"
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './ztictl'
        format: 'table'
        exit-code: '0'  # Don't fail the build
      continue-on-error: true
    
    - name: Run GoSec security scan
      working-directory: ./ztictl
      run: |
        echo "ðŸ”’ Running comprehensive security analysis..."
        
        # Run golangci-lint with security linters enabled
        echo "Running golangci-lint with security checks..."
        $(go env GOPATH)/bin/golangci-lint run --enable gosec --out-format=json > golangci-security-report.json || true
        $(go env GOPATH)/bin/golangci-lint run --enable gosec || true
        
        # Try to install and run standalone gosec as backup
        echo "Installing standalone GoSec..."
        curl -sfL https://raw.githubusercontent.com/securego/gosec/master/install.sh | sh -s -- -b $(go env GOPATH)/bin latest || true
        
        if [ -f "$(go env GOPATH)/bin/gosec" ]; then
          echo "Running standalone GoSec analysis..."
          $(go env GOPATH)/bin/gosec -fmt json -out gosec-report.json ./... || true
          $(go env GOPATH)/bin/gosec -fmt table ./... || true
        else
          echo "Standalone GoSec installation failed, using golangci-lint results only"
        fi
        
        echo "ðŸ“Š Security analysis completed"
      continue-on-error: true
    
    - name: Upload security reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          ztictl/gosec-report.json
          ztictl/golangci-security-report.json
        retention-days: 30
      continue-on-error: true
    
    - name: Run Go vulnerability check
      working-directory: ./ztictl
      run: |
        echo "ðŸ” Running Go vulnerability check..."
        govulncheck ./... || true
        echo ""
        echo "ðŸ“Š Go vulnerability check completed"
      continue-on-error: true
    
    - name: Check for outdated dependencies
      working-directory: ./ztictl
      run: |
        echo "ðŸ” Checking for outdated Go dependencies..."
        echo "Current dependencies:"
        go list -m all
        echo ""
        echo "Checking for updates (this is informational only):"
        go list -u -m all | grep -E '\[.*\]' || echo "All dependencies appear to be up to date"
        echo ""
        echo "ðŸ“Š Dependency update check completed"
      continue-on-error: true
    
    - name: Run comprehensive quality checks
      working-directory: ./ztictl
      run: |
        echo "ðŸ” Running comprehensive quality checks..."
        
        # Standard Go quality checks
        echo "Running go vet..."
        go vet ./... || echo "go vet found issues"
        
        echo "Running go fmt check..."
        UNFORMATTED=$(gofmt -s -l .)
        if [ -n "$UNFORMATTED" ]; then
          echo "âš ï¸  The following files need formatting:"
          echo "$UNFORMATTED"
        else
          echo "âœ… All Go files are properly formatted"
        fi
        
        # Build test to ensure everything compiles
        echo "Testing compilation..."
        go build ./... || echo "âŒ Build failed"
        
        echo "ðŸ“Š Quality checks completed"
      continue-on-error: true
    
    - name: Security scan summary
      run: |
        echo "ðŸ›¡ï¸  Security & Quality Analysis Summary"
        echo "========================================"
        echo "âœ… Trivy filesystem scan completed"
        echo "âœ… golangci-lint with GoSec enabled completed"
        echo "âœ… Standalone GoSec analysis attempted"
        echo "âœ… Go vulnerability check completed"
        echo "âœ… Dependency update check completed"
        echo "âœ… Comprehensive quality checks completed"
        echo ""
        echo "â„¹ï¸  This job runs security and quality scans for informational purposes."
        echo "â„¹ï¸  Review the output above for any security findings or quality issues."
        echo "â„¹ï¸  Security reports are uploaded as artifacts for detailed review."
        echo "â„¹ï¸  Consider updating outdated dependencies regularly."

    - name: Notify on security failure
      if: failure() && github.event_name == 'pull_request'
      env:
        GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
      run: |
        if [[ -n "$GOOGLE_CHAT_WEBHOOK" ]]; then
          ./scripts/send-pr-notification.sh \
            --pr-title '${{ github.event.pull_request.title }}' \
            --pr-number '${{ github.event.pull_request.number }}' \
            --pr-url '${{ github.event.pull_request.html_url }}' \
            --author '${{ github.event.pull_request.user.login }}' \
            --repository '${{ github.repository }}' \
            --status "failure" \
            --message "âŒ Security analysis failed - PR needs attention" || true
        fi
      continue-on-error: true

    - name: Notify on all tests success
      if: success() && github.event_name == 'pull_request'
      env:
        GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
      run: |
        if [[ -n "$GOOGLE_CHAT_WEBHOOK" ]]; then
          ./scripts/send-pr-notification.sh \
            --pr-title '${{ github.event.pull_request.title }}' \
            --pr-number '${{ github.event.pull_request.number }}' \
            --pr-url '${{ github.event.pull_request.html_url }}' \
            --author '${{ github.event.pull_request.user.login }}' \
            --repository '${{ github.repository }}' \
            --status "success" \
            --message "âœ… All tests passed - PR is ready for review" || true
        fi
      continue-on-error: true


  build:
    name: Cross-Platform Build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
          - goos: windows
            goarch: arm64
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.25'
        
    - name: Get dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Build binary
      working-directory: ./ztictl
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
      run: |
        # Set version from tag or default with git commit
        GIT_COMMIT=${GITHUB_SHA::8}
        if [[ "$GITHUB_REF" == refs/tags/* ]]; then
          BASE_VERSION=${GITHUB_REF#refs/tags/v}
          VERSION="${BASE_VERSION}-${GIT_COMMIT}"
        else
          VERSION="dev-${GIT_COMMIT}"
        fi
        
        echo "Building version: ${VERSION}"
        
        # Set output filename
        BINARY_NAME="ztictl-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        # Build with version and optimization flags
        go build \
          -ldflags "-X main.Version=${VERSION} -s -w" \
          -o "${BINARY_NAME}" \
          ./cmd/ztictl
        
        # Verify binary
        if [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "amd64" ]; then
          ./"${BINARY_NAME}" --version
        fi
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ztictl-${{ matrix.goos }}-${{ matrix.goarch }}
        path: ztictl/ztictl-${{ matrix.goos }}-${{ matrix.goarch }}*
        retention-days: 30

  release:
    name: GitHub Release
    runs-on: ubuntu-latest
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
    
    - name: Prepare release binaries
      run: |
        mkdir -p release/
        
        # Copy binaries directly for easier installation
        for dir in artifacts/*/; do
          platform=$(basename "$dir")
          cd "$dir"
          
          # Copy binary directly (users expect direct download)
          cp ./* "../../release/"
          
          # Also create archives for those who prefer them
          if [[ "$platform" == *"windows"* ]]; then
            zip -r "../../release/${platform}.zip" ./*
          else
            tar -czf "../../release/${platform}.tar.gz" ./*
          fi
          
          cd - > /dev/null
        done
        
        echo "Direct binaries and archives:"
        ls -la release/
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: release/*
        draft: false
        prerelease: false
        body_path: RELEASE_NOTES.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


  # Notification for releases (when version tags are pushed)
  release-notification:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [release]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Send release notification
        env:
          GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
        run: |
          set -euo pipefail
          
          # Extract version from tag with validation
          if [[ "$GITHUB_REF" =~ ^refs/tags/v.+ ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            echo "Error: Invalid tag format in GITHUB_REF: $GITHUB_REF"
            exit 1
          fi
          
          # Create release URL
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${VERSION}"
          
          ./scripts/send-release-notification.sh \
            --version "$VERSION" \
            --release-url "$RELEASE_URL" \
            --repository '${{ github.repository }}'
        continue-on-error: true
