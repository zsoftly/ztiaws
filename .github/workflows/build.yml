name: CI/CD Pipeline

# Git Flow Pattern:
# 1. Create release branch from main (e.g., release/v2.0.0)
# 2. Make release preparations (version updates, changelog, etc.)
# 3. Push tag to trigger this workflow (e.g., v2.0.0)
# 4. Workflow builds, tests, and creates GitHub release
# 5. MANUAL: Merge release branch back to main when ready
# 6. Main branch stays up-to-date with all release changes

on:
  push:
    branches: [ main, 'feature/*', 'feat/*', 'issue/*', 'release/*' ]
    tags:
      - 'v*'
    paths:
      - 'ztictl/**'
      - '.github/workflows/**'
      - 'docs/**'
      - 'CHANGELOG.md'
  pull_request:
    branches: [ main, 'release/*' ]
    paths:
      - 'ztictl/**'
      - '.github/workflows/**'
      - 'docs/**'
      - 'CHANGELOG.md'
  workflow_dispatch:

jobs:
  test:
    name: Test & Validate
    runs-on: ${{ matrix.os }}
    if: github.event_name == 'pull_request' || (github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/'))
    
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
        
    - name: Get dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Run tests
      working-directory: ./ztictl
      run: go test -v ./...
        
    - name: Run go vet
      working-directory: ./ztictl
      run: go vet ./...
      
    - name: Check formatting
      working-directory: ./ztictl
      shell: bash
      run: |
        # Ensure consistent line endings across platforms
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          # Configure git to handle line endings properly for this check
          git config core.autocrlf false
          # Re-checkout files with correct line endings
          git checkout HEAD -- .
        fi
        
        # Check if any files need formatting
        UNFORMATTED=$(gofmt -s -l .)
        if [ -n "$UNFORMATTED" ]; then
          echo "The following files are not formatted correctly:"
          echo "$UNFORMATTED"
          echo ""
          echo "Please run 'gofmt -s -w .' to fix formatting issues."
          exit 1
        fi
        echo "All Go files are properly formatted."
    
    - name: Test build
      working-directory: ./ztictl
      run: go build -o ztictl${{ matrix.os == 'windows-latest' && '.exe' || '' }} ./cmd/ztictl
    
    - name: Test CLI commands (no auth required)
      working-directory: ./ztictl
      shell: bash
      run: |
        # Set executable name based on OS
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          ZTICTL_EXE="./ztictl.exe"
        else
          ZTICTL_EXE="./ztictl"
        fi
        
        # Test help commands
        $ZTICTL_EXE --help
        $ZTICTL_EXE config --help
        $ZTICTL_EXE auth --help
        $ZTICTL_EXE ssm --help
        
        # Test version
        $ZTICTL_EXE --version
        
        # Test config validation (should fail gracefully without config)
        $ZTICTL_EXE config validate || echo "Expected to fail without config"
        
        # Test config show (should show defaults)
        $ZTICTL_EXE config show || echo "Expected to work with defaults"
        
        # Test system check (should work without AWS)
        $ZTICTL_EXE config check || echo "Expected to show missing dependencies"

  security:
    name: Security Analysis
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'pull_request' && github.base_ref == 'main'
    env:
      GOPROXY: proxy.golang.org,direct
      GOSUMDB: sum.golang.org
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
        
    - name: Download dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Install security tools
      run: |
        # Install govulncheck for official Go vulnerability checking
        go install golang.org/x/vuln/cmd/govulncheck@latest
        
        # Verify installation
        govulncheck -version || echo "govulncheck installation failed"
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: './ztictl'
        format: 'table'
        exit-code: '0'  # Don't fail the build
      continue-on-error: true
    
    - name: Run GoSec security scan
      uses: securego/gosec@master
      with:
        args: './ztictl/...'
      continue-on-error: true
    
    - name: Run Go vulnerability check
      working-directory: ./ztictl
      run: |
        echo "🔍 Running Go vulnerability check..."
        govulncheck ./... || true
        echo ""
        echo "📊 Go vulnerability check completed"
      continue-on-error: true
    
    - name: Check for outdated dependencies
      working-directory: ./ztictl
      run: |
        echo "🔍 Checking for outdated Go dependencies..."
        echo "Current dependencies:"
        go list -m all
        echo ""
        echo "Checking for updates (this is informational only):"
        go list -u -m all | grep -E '\[.*\]' || echo "All dependencies appear to be up to date"
        echo ""
        echo "📊 Dependency update check completed"
      continue-on-error: true
    
    - name: Security scan summary
      run: |
        echo "🛡️  Security Analysis Summary"
        echo "=============================="
        echo "✅ Trivy filesystem scan completed"
        echo "✅ GoSec security analysis completed"
        echo "✅ Go vulnerability check completed"
        echo "✅ Dependency update check completed"
        echo ""
        echo "ℹ️  This job runs security scans for informational purposes."
        echo "ℹ️  Review the output above for any security findings."
        echo "ℹ️  Consider updating outdated dependencies regularly."

  build:
    name: Cross-Platform Build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
          - goos: windows
            goarch: arm64
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.24'
        
    - name: Get dependencies
      working-directory: ./ztictl
      run: go mod download
    
    - name: Build binary
      working-directory: ./ztictl
      env:
        GOOS: ${{ matrix.goos }}
        GOARCH: ${{ matrix.goarch }}
      run: |
        # Set version from tag or default with git commit
        GIT_COMMIT=${GITHUB_SHA::8}
        if [[ "$GITHUB_REF" == refs/tags/* ]]; then
          BASE_VERSION=${GITHUB_REF#refs/tags/v}
          VERSION="${BASE_VERSION}-${GIT_COMMIT}"
        else
          VERSION="dev-${GIT_COMMIT}"
        fi
        
        echo "Building version: ${VERSION}"
        
        # Set output filename
        BINARY_NAME="ztictl-${{ matrix.goos }}-${{ matrix.goarch }}"
        if [ "${{ matrix.goos }}" = "windows" ]; then
          BINARY_NAME="${BINARY_NAME}.exe"
        fi
        
        # Build with version and optimization flags
        go build \
          -ldflags "-X main.Version=${VERSION} -s -w" \
          -o "${BINARY_NAME}" \
          ./cmd/ztictl
        
        # Verify binary
        if [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "amd64" ]; then
          ./"${BINARY_NAME}" --version
        fi
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ztictl-${{ matrix.goos }}-${{ matrix.goarch }}
        path: ztictl/ztictl-${{ matrix.goos }}-${{ matrix.goarch }}*
        retention-days: 30

  release:
    name: GitHub Release
    runs-on: ubuntu-latest
    needs: [build]
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
    
    - name: Prepare release binaries
      run: |
        mkdir -p release/
        
        # Copy binaries directly for easier installation
        for dir in artifacts/*/; do
          platform=$(basename "$dir")
          cd "$dir"
          
          # Copy binary directly (users expect direct download)
          cp ./* "../../release/"
          
          # Also create archives for those who prefer them
          if [[ "$platform" == *"windows"* ]]; then
            zip -r "../../release/${platform}.zip" ./*
          else
            tar -czf "../../release/${platform}.tar.gz" ./*
          fi
          
          cd - > /dev/null
        done
        
        echo "Direct binaries and archives:"
        ls -la release/
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: release/*
        draft: false
        prerelease: false
        body_path: RELEASE_NOTES.txt
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Notification for PR events (opened to main branch)
  pr-notification:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.event.action == 'opened' || github.event.action == 'reopened') && github.base_ref == 'main'
    needs: [security]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Send PR notification
        env:
          GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
        run: |
          ./scripts/send-pr-notification.sh \
            --pr-title "${{ github.event.pull_request.title }}" \
            --pr-number "${{ github.event.pull_request.number }}" \
            --pr-url "${{ github.event.pull_request.html_url }}" \
            --author "${{ github.event.pull_request.user.login }}" \
            --repository "${{ github.repository }}"

  # Notification for releases (when version tags are pushed)
  release-notification:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [release]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Send release notification
        env:
          GOOGLE_CHAT_WEBHOOK: ${{ secrets.GOOGLE_CHAT_WEBHOOK }}
        run: |
          # Extract version from tag
          VERSION=${GITHUB_REF#refs/tags/}
          
          # Create release URL
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/${VERSION}"
          
          ./scripts/send-release-notification.sh \
            --version "$VERSION" \
            --release-url "$RELEASE_URL" \
            --repository "${{ github.repository }}"
